# 实现的功能

实现了死锁检测，这里最重要的是把锁理解成一种资源，安全性检测的过程实际就是模拟每个线程取锁释放锁的过程，如果存在资源无法被满足的情况即视为不安全，但不安全并不一定意为着死锁，只是有死锁的可能性。

# 问答

1. 在我们的多线程实现中，当主线程 (即 0 号线程) 退出时，视为整个进程退出， 此时需要结束该进程管理的所有线程并回收其资源。 - 需要回收的资源有哪些？ - 其他线程的 TaskControlBlock 可能在哪些位置被引用，分别是否需要回收，为什么？

操作系统的 TaskManager 管理着 TaskControlBlock， 其中 TaskControlBlock 管理着进程 PCB，看看 PCB 中有哪些内容，地址空间，文件描述符表，父子进程引用，各种同步互斥资源，管道资源，显然，这些都是需要被回收的，还有它管理者所有线程,具体可以看 exit_current_and_run_next 方法中，当 tid == 0 时的实现。
在 Unix/Linux 系统中，主进程退出后，子进程会被重新分配给 initproc 变成孤儿进程，因此其它线程的 TCB 可能被子进程引用，此时需要把它挂到初始 INITPROC 进程下，TCB 还会被互斥资源引用，比如在锁的等待队列中等，这些都应该要回收，整个地址空间都回收了，这些还有啥用呢。

2. 对比以下两种 Mutex.unlock 的实现，二者有什么区别？这些区别可能会导致什么问题？
   前者先解锁后唤醒任务，后者先唤醒任务，如果没有可唤醒的任务才修改锁标识，前者实现会有问题，如果在解锁后下一个任务进入临界区期间，其它任务可能会拿到锁，就会有竞态条件了，后者更健壮。

# 荣誉准则

1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

    与群友吹水未获得启发

2. 此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

    参考了博文与第三方的实现，但我确认且清楚理解了安全性算法检测的原理与实现。
    https://blog.csdn.net/weixin_44246009/article/details/108548948

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。
